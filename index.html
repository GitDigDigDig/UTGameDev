<!DOCTYPE html>

<html>

<head>

    <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.js"></script>

</head>

<body>

    <script>
        // teddy was here

    var config = {
        type: Phaser.AUTO,
        width: 1200,
        height: 700,
        physics: {
            default: 'arcade',
        },

        scene: {
            preload: preload,
            create: create,
            update: update,
        }

    };

    class Player extends Phaser.Physics.Arcade.Sprite
    {
        totalJumps = 2;
        currentJumps = 0;
        collectedCarrots = 0;
        constructor(scene, x, y)
        {
            super(scene, x, y, 'none');
            scene.add.existing(this);
            scene.physics.add.existing(this);
            this.setScale(2);
            this.setCollideWorldBounds(true);
            this.setGravityY(0); //We will set gravity *per object* rather than for the scene!
        }
    }

    class Wabbit extends Phaser.Physics.Arcade.Sprite{
        totalJumps = 2;
        currentJumps = 0;
        collectedCarrots = 0;
        constructor(scene, x, y)
        {
            super(scene, x, y, 'wabbit');
            scene.add.existing(this);
            scene.physics.add.existing(this);
            this.setScale(2);
            this.setCollideWorldBounds(true);
            this.setGravityY(3000); //We will set gravity *per object* rather than for the scene!
        }
    }

    class Slime extends Player{
        animations;
        constructor(scene, x, y, spritesheet, animations)
        {
            super(scene, x, y, spritesheet);
            this.animations = animations;
            scene.add.existing(this);
            scene.physics.add.existing(this);
            this.setScale(2);
            this.setCollideWorldBounds(true);
            this.setGravityY(3000); 
        }
    }
    

    class Carrot extends Phaser.Physics.Arcade.Sprite
    {
        constructor(scene, x, y)
        {
            super(scene, x, y, 'carrot');
            scene.add.existing(this);
            scene.physics.add.existing(this);
            this.setCollideWorldBounds(true);
            this.setGravityY(3000);
        }
    }

    var game = new Phaser.Game(config);

    //Game Objects
    var platforms;
    let player;
    var playerKey = 0;
    var playerList= [];
    var carrots = [];
    var totalCarrots = 12;

    //Keyboard controls
    var cursors;
    var keys;
    var space;

    var gui;
    var guiTimer;

    function preload()
    {
        this.load.image('sky', 'assets/clouds.png');
        this.load.image('platform', 'assets/platform.png');
        this.load.image('wabbit', 'assets/wabbit.png');
        this.load.image('carrot', 'assets/carrot.png');
        this.load.atlas('slime', 'assets/slimesheet.png', 'assets/slimesheet.json');
    }

    function create()
    {
        //Set the background origin to be at (0, 0) or top left corner of the image rather than the center of the image asset
       let background = this.add.tileSprite(0, 0, game.scale.width, game.scale.height, 'sky').setOrigin(0, 0);

       let slimeAnimations = {};
       slimeAnimations['idle'] = this.anims.create({key: 'slime_idle', frames: this.anims.generateFrameNames('slime', {prefix: 'slime_idle', end: 5, zeroPad: 2}), repeat: -1, frameRate: 10});
       slimeAnimations['left']  = this.anims.create({key: 'slime_left', frames: this.anims.generateFrameNames('slime', {prefix: 'slime_left', end: 5, zeroPad: 2}), repeat: -1, frameRate: 10});
       slimeAnimations['right'] = this.anims.create({key: 'slime_right', frames: this.anims.generateFrameNames('slime', {prefix: 'slime_right', end: 5, zeroPad: 2}), repeat: -1, frameRate: 10});

       //Create the platforms and the player character set to collide with the platforms
       createPlatforms(this);
       player = new Wabbit (this, 400, 500);
       playerList.push(player);
       player = new Slime (this, 200, 500, 'slime', slimeAnimations);
       playerList.push(player);
       player.play(player.animations['idle']);
       this.physics.add.collider(playerList, platforms);
       
       player = playerList[playerKey]

        //Create the Camera Follow
        let camera = this.cameras.main;
        //camera.setBounds(-100, -100, 1300, 700);
        camera.startFollow(player);

       //Create the carrot interactables
       for (var i = 0; i < totalCarrots; i++)
       {
           let myCarrot = new Carrot(this, Phaser.Math.Between(0, game.scale.width), Phaser.Math.Between(0, game.scale.height-80));
           this.physics.add.collider(myCarrot, platforms);
           carrots.push(myCarrot);
       }

       this.physics.add.overlap(playerList, carrots, eatCarrot, null, this);

       //Set up user input
       cursors = this.input.keyboard.createCursorKeys();
       keys = this.input.keyboard.addKeys('A, D, S');
       space = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
       space.on('down', jump); //calls jump function when space is pressed
       keys.S.on('down', switchPlayer); //calls jump function when space is pressed

       gui = this.add.text(500, 100, '', {fontSize: '32px', fill: '#000'});
       graphics = this.add.graphics();
    }


    function createPlatforms(scene)
    {
        platforms = scene.physics.add.staticGroup();

        //basePlatform is the floor of the game
        let basePlatform = platforms.create(game.scale.width/2, game.scale.height-30, 'platform');
        basePlatform.setScale(3, 1).refreshBody(); //scales the base platform in the x axis to cover the entire floor

        platforms.create(250, 350, 'platform'); //creates the upper left platform
        platforms.create(950, 500, 'platform'); //creates the bottome right platform
    }

    function update()
    {
        //Player will not move in the x-axis unless a movement key is being pressed
        player.setVelocityX(0);

        //Player has "drag" on the x-axis meaning they slide a bit after an input
        player.setDragX(1000);

        //This will reset the number of jumps available to the player whenever the player lands
        if (player.body.touching.down) {
            player.currentJumps = 0;
        }

        //Handle player movements
        movement()
        playerAnimation()
    }
    

    function movement() {
        if (cursors.left.isDown)
        {
            player.setVelocityX(-200);
        } else if (cursors.right.isDown)
        {
            player.setVelocityX(200);
        }
    }

    function playerAnimation() {
        if (playerKey == 1) {
            //playerList[0].play(playerList[0].animations['idle'], true)
            if (cursors.left.isDown)
            {
                playerList[1].play(playerList[1].animations['left'], true);
            } else if (cursors.right.isDown)
            {
                playerList[1].play(playerList[1].animations['right'], true);
            } else 
            {
                playerList[1].play(playerList[1].animations['idle'], true);
            }
        } else {
            playerList[1].play(playerList[1].animations['idle'], true);
            if (cursors.left.isDown)
            {
                //playerList[0].play(playerList[0].animations['left'], true);
            } else if (cursors.right.isDown)
            {
                //playerList[0].play(playerList[0].animations['right'], true);
            } else 
            {
                //playerList[0].play(playerList[0].animations['idle'], true);
            }
        } 
    }

    function jump(event)
    {
        if (player.body.touching.down) {
          //If the player is on the ground, the player can jump
          player.setVelocityY(-1100);
          player.currentJumps++;
        } else if (player.currentJumps < player.totalJumps) {
          //If the player is not on the ground but has an available air jump, use that jump
          player.setVelocityY(-800);
          player.currentJumps++;
        }
    }

    function switchPlayer() {
        gui.setText('Switch Player');
        //this.camera.main.stopFollow();
        playerKey = (playerKey + 1) % playerList.length;
        player = playerList[playerKey];
        let camera = this.cameras.main;
        camera.startFollow(player);
    }

    //This function is called when a player overlaps with a carrot
    function eatCarrot(player, carrot)
    {
        player.collectedCarrots++;
        carrot.disableBody(true, true); //remove that particular carrot from the game (physics and visibility)
        if (player.collectedCarrots < totalCarrots)
        {
          gui.setText('Yum yum!');
          guiTimer = this.time.delayedCall(1000, removeText, [], this);
        } else
        {
          gui.setText('You Win!');
          player.disableBody(true, false);
          guiTimer.remove(false);
        }
    }

    //Reset the gui text to be empty after the guiTimer elapses
    function removeText()
    {
        if (player.collectedCarrots < totalCarrots)
          gui.setText('');
    }

    </script>

</body>

</html>
